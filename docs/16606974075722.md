# 大文件

## 分块传输
> 在响应报文里用头字段 Transfer-Encoding: chunked 来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块逐个发送

> 分块传输也可以用于流式数据，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段 Content-Length 里给出确切的长度，所以也只能用 chunked 方式分块发送

> Transfer-Encoding: chunked 和 Content-Length 这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知

> 1. 每个分块包含两个部分，长度头和数据块
> 2. 长度头是以 CRLF 结尾的一行明文，用 16 进制数字表示长度
> 3. 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF
> 4. 最后用一个长度为 0 的块表示结束

## 范围请求
> 允许客户端在请求头里使用专用字段来表示只获取文件的一部分。范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段 Accept-Ranges: bytes 明确告知客户端是支持范围请求的

> 如果不支持，服务器可以发送 Accept-Ranges: none，或者干脆不发送 Accept-Ranges 字段，这样客户端就认为服务器没有实现范围请求功能

> 请求头 Range 是 HTTP 范围请求的专用字段，格式是 bytes=x-y，其中的 x 和 y 是以字节为单位的数据范围

> 服务器收到 Range 字段后，做四件事：
> 1. 检查范围是否合法，如果范围越界，服务器就会返回状态码 416
> 2. 如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码 206 Partial Content，表示 body 只是原数据的一部分
> 3. 服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是 bytes x-y/length

> 常用的下载工具里的多段下载、断点续传也是基于范围请求实现的：
> 1. 先发 HEAD，看服务器是否支持范围请求，同时获取文件的大小
> 2. 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据
> 3. 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了

> 支持在 Range 头里使用多个 x-y，一次性获取多个片段数据。这种情况需要使用一种特殊的 MIME 类型：multipart/byteranges，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数 boundary=xxx 给出段之间的分隔标记