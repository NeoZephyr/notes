# 垃圾回收器

> Java8 版本的 Hotspot JVM，默认情况下使用的是并行垃圾收集器（Parallel GC）
> Java9 之后，官方 JDK 默认使用的垃圾收集器是 G1

## 串行
> 回收算法：复制算法/标记-清除算法
> 单线程复制回收，简单高效，但会暂停程序导致停顿

> -XX:+UseSerialGC：年轻代、老年代回收器为：Serial New、Serial Old
> -XX:+USeParNewGC：改进版本的 Serial GC，年轻代、老年代回收器为：ParNew New、Serial Old，jdk1.8 中无效

## 并行
> 回收算法：复制算法/标记-整理算法
> 并行回收器适用于多核服务器，主要目标是增加吞吐量。多线程复制回收，降低了停顿时间，但容易增加上下文切换

> -XX:+UseParallelGC：年轻代、老年代回收器为：Parallel Scavenge、Serial Old
> -XX:+UseParallelGC -XX:+UseParallelOldGC：年轻代、老年代回收器为：Parallel Scavenge、Parallel Old

> -XX:ParallelGCThreads=N 指定 GC 线程数，其默认值为 CPU 核心数

## CMS
> 回收算法：标记-清除算法

> -XX:+UseConcMarkSweepGC

> CMS 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
> 1. 不对老年代进行整理，而是使用空闲列表来管理内存空间的回收
> 2. 在标记-清除阶段的大部分工作和应用线程一起并发执行，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4

> 如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么可以使用 CMS

> CMS 最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下会造成不可预测的暂停时间，特别是堆内存较大的情况下

> CMS 过程分为如下步骤：
> 1. Initial Mark，初始化标记：发生 STW，暂停所有应用线程，并行标记可直达的存活对象（包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象）
> 2. Concurrent Mark，并发标记：GC 线程和应用线程并发执行，从前一阶段找到的根对象开始递归遍历老年代，标记所有的存活对象
> 3. Concurrent Preclean，并发预清理：因为前一阶段是并发执行，对象可能会发生变化，JVM 会通过 Card 的方式将发生了改变的区域标记为脏区，这就是所谓的卡片标记
> 4. Final Remark，重新标记：发生 STW，暂停所有应用线程，完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度，所以需要一次 STW 暂停来处理各种复杂的情况
> 5. Concurrent Sweep，并发清理：删除不再使用的对象，并回收他们占用的内存空间
> 6. Concurrent Reset，并发重置：并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备

## G1
> G1 将堆划分为多个（通常是 2048 个）可以存放对象的小块堆区域。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代

> G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理：每次只处理一部分内存块，称为此次 GC 的回收集。每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集

> -XX:+UseG1GC -XX:MaxGCPauseMillis=50

> -XX:G1NewSizePercent：初始年轻代占整个 Java Heap 的大小，默认值为 5%
> -XX:G1MaxNewSizePercent：最大年轻代占整个 Java Heap 的大小，默认值为 60%
> -XX:G1HeapRegionSize：设置每个 Region 的大小，单位 MB，需要为 1，2，4，8，16，32 中的某个值，默认是堆内存的 1/2000
> -XX:ConcGCThreads：与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1/4
> -XX:+InitiatingHeapOccupancyPercent：G1 内部并行回收循环启动的阈值，默认为 Java Heap 的 45%
> -XX:G1HeapWastePercent：G1 停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中的对象，但是如果下降到了 5%，就会停下来不再收集了
> -XX:+GCTimeRatio：这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9。主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100 / (1+GCTimeRatio)。如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面
> -XX:MaxGCPauseMills：预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是 200 毫秒，G1 会尽量保证控制在这个范围内

> G1 过程分为如下步骤：
> 1. 年轻代模式转移暂停：G1 通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。拷贝的过程称为转移
> 2. 并发标记：在标记阶段开始时记下所有的存活对象，即使在标记的同时又有一些变成了垃圾。通过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。这些信息在接下来的阶段会用来执行老年代区域的垃圾收集

> 有两种情况是可以完全并发执行的：
> 1. 如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾
> 2. 在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块

> 当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45%。G1 的并发标记也是由多个阶段组成

> 初始标记：标记所有从 GC 根对象直接可达的对象
Root 区扫描：标记所有从根区域可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域
> 并发标记：只遍历对象图，并在一个特殊的位图中标记能访问到的对象
> 再次标记：这是一次 STW 停顿，以完成标记过程。G1 收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象
> 清理：统计小堆块中所有存活的对象，并将小堆块进行排序，以提升 GC 的效率，维护并发标记的内部状态。所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停

> 3. 转移暂停：并发标记完成之后，G1 将执行一次混合收集。就是不只清理年轻代，还将一部分老年代区域也加入到回收集中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停

> 某些情况下 G1 触发了 Full GC，会退化使用 Serial 收集器来完成垃圾的清理工作，GC 暂停时间将达到秒级别的：
> 1. 并发模式失败：G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。解决办法：增加堆大小或者调整周期（例如增加线程数 -XX:ConcGCThreads 等)
> 2. 晋升失败：没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC

> 解决办法：
> - 增加 –XX:G1ReservePercent 选项的值（并相应增加总的堆大小）增加预留内存量
> - 通过减少 –XX:InitiatingHeapOccupancyPercent 提前启动标记周期
> - 也可以通过增加 –XX:ConcGCThreads 选项的值来增加并行标记线程的数目

> 3. 巨型对象分配失败：当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间

> 解决办法：增加内存或者增大 -XX:G1HeapRegionSize

## ZGC
> -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g

> ZGC 最主要的特点包括：
> 1. GC 最大停顿时间不超过 10ms
> 2. 堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆内存
> 3. 与 G1 相比，应用吞吐量下降不超过 15%
> 4. 当前只支持 Linux/x64 位平台，JDK15 后支持 MacOS 和 Windows 系统

## ShennandoahGC
> -XX:+UnlockExperimentalVMOptions XX:+UseShenandoahGC -Xmx16g