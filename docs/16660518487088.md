# 基础类型

> 1. boolean，值域：{false, true}，默认值：false，虚拟机内部符号：Z
> 2. byte，值域：[-128, 127]，默认值：0，虚拟机内部符号：B
> 3. short，值域：[-32768, 32767]，默认值：0，虚拟机内部符号：S
> 4. char，值域：[0, 65535]，默认值：'\u0000'，虚拟机内部符号：C
> 5. int，值域：[-2^31, 2^31-1]，默认值：0，虚拟机内部符号：I
> 6. long，值域：[-2^63, 2^63-1]，默认值：0L，虚拟机内部符号：J
> 7. float，值域：[-3.4E38, 3.4E38]，默认值：+0.0F，虚拟机内部符号：F
> 8. double，值域：[-1.8E308, 1.8E308]，默认值：+0.0D，虚拟机内部符号：D

> byte、short、int、long、float 以及 double 的值域依次扩大，而且前面的值域被后面的值域所包含。因此，从前面的基本类型转换至后面的基本类型，无需强制转换（byte, short, char 不同或者相同类型运算都会转换为 int 类型）

> 尽管这些数据类型的默认值看起来不一样，但在内存中都是 0

> boolean 和 char 是唯二的无符号类型。在不考虑违反规范的情况下，boolean 类型的取值范围是 0 或者 1。char 类型的取值范围则是 [0, 65535]

> Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。前者在 Java 里是 0，后者是符号位为 1、其他位均为 0 的浮点数，在内存中等同于十六进制整数 0x8000000（即 -0.0F 可通过 Float.intBitsToFloat(0x8000000) 求得）。尽管它们的内存数值不同，但是在 Java 中 +0.0F == -0.0F 会返回真

> 正无穷就是任意正浮点数（不包括 +0.0F）除以 +0.0F 得到的值，而负无穷是任意正浮点数除以 -0.0F 得到的值。正无穷和负无穷在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000

> [0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应的都是 NaN。一般计算得出的 NaN，比如说 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，称之为标准的 NaN，而其他的称之为不标准的 NaN

> NaN 有一个特性：除了 != 始终返回 true 之外，所有其他比较结果都会返回 false

## 类型的大小
> Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的 this 指针以及方法所接收的参数

> 在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元

> 也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节

> 这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，跟这些类型的值域相吻合。当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，高两位的字节便会被截取掉，最终存入 \uFFFF

> boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中

> Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。对于 byte、short 这两个类型来说，加载伴随着符号扩展

## byte 陷阱

```java
byte a = 1;
byte b1 = 1;
byte b2 = 4;

// ok: 没有超过 byte 范围
a = 1 + 4;

// fail: 可能超过 byte 范围
a = a + 4;
// fail: 可能超过 byte 范围
a = b1 + b2;
```

## long

```java
long a = 1234L;
```

## float

```java
float f = 3.14f;
```

## 二进制表示

```java
Integer.toBinaryString(a);
Integer.toHexString(a);
Integer.toBinaryString(Float.floatToInBits(a));
```