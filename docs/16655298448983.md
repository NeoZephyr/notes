# 类加载器

> 类加载过程由类加载器来完成，系统自带的类加载器分为三种：
> 1. BootstrapClassLoader：启动类加载器，是用原生 C++ 代码来实现的，并不继承自  java.lang.ClassLoader，在 Java 的 API 里无法拿到
> 2. ExtClassLoader：扩展类加载器，继承自 URLClassLoader 类。负责加载 jre\lib\ext 下，或由 java.ext.dirs 系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器
> 3. AppClassLoader：应用类加载器，继承自 URLClassLoader 类。在应用程序代码里可以通过 ClassLoader 的静态方法 getSystemClassLoader 来获取应用类加载器。如果没有使用自定义类加载器，则用户自定义的类都由此加载器加载
> 4. 自定义类加载器：自定义类加载器都以应用类加载器作为父加载器。应用类加载器的父类加载器为扩展类加载器

## 双亲委托
> 当一个自定义类加载器需要加载一个类，它不会直接试图加载它，而是先委托自己的父加载器去加载，父加载器如果发现自己还有父加载器，会一直往前找，只要上级加载器已经加载了这个类，所有的子加载器都不需要自己加载了。如果几个类加载器都没有加载到指定名称的类，那么会抛出 ClassNotFountException 异常

> 双亲委派模型意义：
> 1. 防止内存中出现多份同样的字节码
> 2. 保证 Java 程序安全稳定运行

> 自定义类加载器：一般都是继承自 ClassLoader 类，只需要重写 findClass 方法即可

> 需要说明的是两个没有关系的自定义类加载器之间加载的类是不共享的，这样就可以实现不同的类型沙箱的隔离性，可以通过多个类加载器，各自加载同一个类的不同版本，可以相互之间不影响彼此，从而在这个基础上可以实现类的动态加载卸载，热插拔的插件机制等

## 负责依赖
> 如果一个加载器在加载某个类的时候，发现这个类依赖于另外几个类或接口，也会去尝试加载这些依赖项

## 缓存加载
> 为了提升加载效率，消除重复加载，一旦某个类被一个类加载器加载，那么它会缓存这个加载结果，不会重复加载