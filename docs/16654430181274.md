# 内存调优

## GC
### GC 组合
> 1. Serial + Serial Old 实现单线程的低延迟垃圾回收机制
> 2. ParNew + CMS 实现多线程的低延迟垃圾回收机制
> 3. Parallel Scavenge + Parallel Scavenge Old 实现多线程的高吞吐量垃圾回收机制

### GC 日志
> 1. -XX:+PrintGC：输出 GC 日志
> 2. -XX:+PrintGCDetails：输出 GC 的详细日志
> 3. -XX:+PrintGCTimeStamps：输出 GC 的时间戳（以基准时间的形式）
> 4. -XX:+PrintGCDateStamps：输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
> 5. -XX:+PrintHeapAtGC：在进行 GC 的前后打印出堆的信息
> 6. -Xloggc:gc.log：日志文件的输出路径
> 7. ‐XX:+HeapDumpOnOutOfMemoryError：指定堆内存溢出时自动进行 Dump 
> 8. ‐XX:HeapDumpPath=/opt/logs


> [GC 日志分割](https://blog.gceasy.io/2016/11/15/rotating-gc-log-files/)
> GCeasy 是一款非常直观的 GC 日志分析工具，可以将日志文件压缩之后，上传到 GCeasy 官网即可看到非常清楚的 GC 日志分析结果

> FastThread 线程分析

### GC 类型
#### Minor GC
> 清理的是年轻代，不处理老年代。会把所有从老年代指向年轻代的引用都当做 GC Root。从年轻代指向老年代的引用则在标记阶段被忽略。

> Minor GC 每次都会引起 STW，挂起所有的应用线程。对大部分应用程序来说，Minor GC 的暂停时间可以忽略不计，因为 Eden 区里面的对象大部分都是垃圾，不需要复制到存活区/老年代

#### Major GC
> 清理老年代空间

#### Full GC
> 清理整个堆内存空间

## 内存分析
### 内存构成
> JVM 内存 = 栈 + 堆 + 非堆（方法区） + 直接内存

### 对象头
> 对象头中一般包含两个部分:
> 1. 标记字，占用一个机器字，也就是8字节
> 2. 类型指针，占用一个机器字，也就是8个字节

> 如果堆内存小于 32GB，JVM 默认会开启指针压缩，则只占用 4 个字节。如果是数组，对象头中还会多出一个数组长度部分，占用4字节

### 多维数组
> 在二维数组 int[dim1][dim2] 中，每个嵌套的数组 int[dim2] 都是一个单独的 Object，会额外占用 16 字节的空间。当数组维度更大时，这种开销特别明显

## 内存调优
### 调优参数
> ‐Xmx 推荐配置系统或容器里可用内存的 70­ ～ 80%

### 调优参考指标
> - GC 频率：高频的 FullGC 会给系统带来非常大的性能消耗，虽然 MinorGC 相对 FullGC 来说好了许多，但过多的 MinorGC 仍会给系统带来压力
> - 堆内存：分析堆内存大小是否合适，年轻代和老年代的比例是否合适。如果内存不足或分配不均匀，会增加 FullGC，严重的将导致 CPU 持续爆满，影响系统性能
> - 吞吐量：频繁的 FullGC 将会引起线程的上下文切换，增加系统的性能开销，从而影响每次处理的线程请求，最终导致系统的吞吐量下降
> - 延时：JVM 的 GC 持续时间也会影响到每次请求的响应时间

### 调优分析
#### 分配速率
> 表示单位时间内分配的内存量。上一次垃圾收集之后，与下一次 GC 开始之前的年轻代使用量，两者的差值除以时间,就是分配速率。分配速率过高就会严重影响程序的性能，在 JVM 中可能会导致巨大的 GC 开销

> 增加年轻代空间并不会降低分配速率，但是会减少 GC 的频率。如果每次 GC 后只有少量对象存活，minor GC 的暂停时间就不会明显增加

#### 过早提升
> 提升速率用于衡量单位时间内从年轻代提升到老年代的数据量。根据分代假设，可能存在一种情况，老年代中不仅有存活时间长的对象，也可能有存活时间短的对象。这就是过早提升：对象存活时间还不够长的时候就被提升到了老年代

> major GC 不是为频繁回收而设计的，但 major GC 现在也要清理这些生命短暂的对象，就会导致 GC 暂停时间过长，这会严重影响系统的吞吐量

> 一般来说过早提升的症状表现为以下形式：
> 1. 短时间内频繁地执行 full GC
> 2. 每次 full GC 后老年代的使用率都很低，在 10- 20% 或以下
> 3. 提升速率接近于分配速率

### 调优方法
#### 减少 MinorGC
> 可以将年轻代设置得大一些，从而减少一些 MinorGC。扩容 Eden 区虽然可以减少 Minor GC 的次数，但会增加单次 Minor GC 的时间。单次 Minor GC 时间是由两部分组成：T1（扫描新生代）和 T2（复制存活对象）

> 如果增大新生代空间，Minor GC 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 Eden 区中被回收掉，此时就不存在复制存活对象了。可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。通常在虚拟机中，复制对象的成本要远高于扫描成本

> 如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加 Minor GC 的时间。如果堆中的短期对象很多，那么扩容新生代，单次 Minor GC 时间不会显著增加。因此，单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小

#### 减少 FullGC
> 在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，可以降低 Full GC 的频率

> 如果大对象超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。这种大对象很容易产生较多的 Full GC

> 可以通过参数 -XX:PetenureSizeThreshold 设置直接被分配到老年代的最大对象

> 设置 Eden、Survivor 区比例：如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor 和 To Survivor 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。这个时候 SurvivorRatio 默认设置的比例会失效

> 在 JDK1.8 中，默认是开启 AdaptiveSizePolicy 的，可以通过 -XX:-UseAdaptiveSizePolicy 关闭该项配置，或显示运行 -XX:SurvivorRatio=8 将 Eden、Survivor 的比例设置为 8:2。如果大部分新对象都是在 Eden 区创建的，可以固定 Eden 区的占用比例，来调优 JVM 的内存分配性能

> 持久代/元数据区在 JDK1.8 之前的参数设置是 -XX:MaxPermSize，之后的参数设置是 -XX:MaxMetaspaceSize